<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>仪器确认附件生成系统</title>
    <script src="https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background-color: #f5f5f5;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);
        }
        
        /* 移动端适配 */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .container {
                padding: 15px;
                border-radius: 5px;
            }
            
            .title {
                font-size: 22px;
            }
            
            .subtitle {
                font-size: 14px;
            }
            
            .upload-section {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .upload-box {
                padding: 15px;
            }
            
            .action-buttons {
                display: flex;
                flex-direction: column;
                gap: 10px;
            }
            
            .export-button, .add-more-button, .clear-cache-button {
                padding: 10px 20px;
                font-size: 14px;
            }
        }
        
        /* 清除缓存按钮样式 */
        .clear-cache-button {
            margin-left: 10px;
            padding: 12px 30px;
            background-color: #e74c3c;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .clear-cache-button:hover {
            background-color: #c0392b;
        }
        
        .clear-cache-button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid #eee;
        }
        
        .title {
            color: #333;
            font-size: 28px;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #666;
            font-size: 16px;
        }
        
        .upload-section {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .upload-box {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
            background-color: #fafafa;
        }
        
        .upload-box:hover {
            border-color: #4a90e2;
            background-color: #f0f7ff;
        }
        
        .upload-box.has-image {
            border-style: solid;
            border-color: #4a90e2;
            background-color: white;
        }
        
        /* 拖拽相关样式 */
        .upload-box.dragging {
            opacity: 0.5;
            transform: scale(0.95);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            z-index: 1000;
        }
        
        .upload-box.drag-over {
            border-color: #2ecc71;
            background-color: #f0fff4;
            border-style: solid;
        }
        
        .drag-handle {
            cursor: move;
            padding: 5px;
            margin-bottom: 10px;
            background-color: #f1f1f1;
            border-radius: 4px;
            text-align: center;
            color: #666;
            font-size: 12px;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }
        
        .drag-handle:hover {
            background-color: #e1e1e1;
        }
        
        /* 移动端优化样式 */
        @media (max-width: 768px) {
            .drag-handle {
                padding: 10px;
                font-size: 14px;
                background-color: #e9e9e9;
                border: 1px solid #ddd;
            }
            
            .upload-box {
                margin-bottom: 15px;
            }
            
            .upload-box.dragging {
                transform: scale(0.98);
            }
            
            /* 移动端触摸反馈 */
            .upload-box:active {
                transform: scale(0.99);
            }
            
            .drag-handle:active {
                background-color: #d9d9d9;
            }
        }
        
        .description-input {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            resize: vertical;
            min-height: 60px;
        }
        
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }
        
        .file-input {
            position: absolute;
            left: -9999px;
        }
        
        .file-input-button {
            display: block;
            width: 100%;
            padding: 10px 15px;
            background-color: #4a90e2;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        
        .file-input-button:hover {
            background-color: #3a80d2;
        }
        
        .file-input-button:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.5);
        }
        
        .image-preview {
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            object-fit: contain;
            transition: transform 0.3s ease;
        }
        
        /* 为图片预览添加容器，确保旋转后不会溢出 */
        .image-preview-container {
            margin-top: 15px;
            width: 100%;
            height: 240px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
        }
        
        .image-preview-container img {
            position: absolute;
            width: auto;
            height: auto;
            max-width: 100%;
            max-height: 100%;
            transform-origin: center;
        }
        
        .remove-image {
            margin-top: 10px;
            padding: 5px 10px;
            background-color: #e74c3c;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .action-buttons {
            text-align: center;
            margin-top: 30px;
        }
        
        .export-button {
            padding: 12px 30px;
            background-color: #2ecc71;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .export-button:hover {
            background-color: #27ae60;
        }
        
        .add-more-button {
            padding: 10px 20px;
            background-color: #f39c12;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
            margin-bottom: 20px;
            transition: background-color 0.3s;
        }
        
        .add-more-button:hover {
            background-color: #e67e22;
        }
        
        .pdf-content {
            padding: 20px;
            background-color: white;
        }
        
        .pdf-header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid #eee;
        }
        
        .pdf-logo {
            max-width: 150px;
        }
        
        .pdf-title {
            color: #333;
            font-size: 24px;
            margin-top: 10px;
        }
        
        .pdf-image-section {
            margin-bottom: 30px;
            page-break-inside: avoid;
        }
        
        .pdf-image-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }
        
        .pdf-image {
            max-width: 100%;
            max-height: 300px;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            background-color: #2ecc71;
            color: white;
            border-radius: 5px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transform: translateX(150%);
            transition: transform 0.3s ease;
            z-index: 1000;
        }
        
        .notification.show {
            transform: translateX(0);
        }
    </style>
</head>
<body>
    <div class="container" id="app">
        <div class="header">
            <h1 class="title">仪器确认附件生成系统</h1>
            <p class="subtitle">上传图片，添加描述，导出为PDF文档</p>
        </div>
        
        <button class="add-more-button" @click="addUploadBox">添加更多上传框</button>
        
        <div class="upload-section">
            <div v-for="(box, index) in uploadBoxes" 
                 :key="index" 
                 class="upload-box" 
                 :class="{'has-image': box.image, 'dragging': box.isDragging, 'drag-over': box.isDragOver}"
                 draggable="true"
                 @dragstart="handleDragStart(index, $event)"
                 @dragend="handleDragEnd(index, $event)"
                 @dragover="handleDragOver(index, $event)"
                 @drop="handleDrop(index, $event)"
                 @dragenter="handleDragEnter(index, $event)"
                 @dragleave="handleDragLeave(index, $event)"
                 @touchstart="handleTouchStart(index, $event)"
                 @touchmove="handleTouchMove(index, $event)"
                 @touchend="handleTouchEnd(index, $event)"
                 @touchcancel="handleTouchCancel(index, $event)">
                
                <div class="drag-handle">☰ 拖动调整顺序</div>
                
                <textarea 
                    v-model="box.description" 
                    class="description-input" 
                    :placeholder="'请输入第 ' + (index + 1) + ' 张图片的描述...'">
                </textarea>
                
                <div class="file-input-wrapper">
                    <input 
                        type="file" 
                        :id="'file-input-' + index" 
                        class="file-input" 
                        accept="image/*"
                        @change="handleFileChange($event, index)">
                    <button 
                        type="button"
                        class="file-input-button"
                        @click="document.getElementById('file-input-' + index).click()">
                        {{ box.image ? '更换图片' : '选择图片' }}
                    </button>
                </div>
                
                <div v-if="box.image" class="image-preview-container">
                    <img :src="box.image" class="image-preview" :alt="'图片 ' + (index + 1)" :style="getImageStyle(box.rotation)">
                </div>
                
                <div v-if="box.image" style="margin-top: 10px; display: flex; gap: 10px; justify-content: center;">
                    <button class="remove-image" @click="rotateImage(index)">旋转图片</button>
                    <button class="remove-image" @click="removeImage(index)">移除图片</button>
                </div>
            </div>
        </div>
        
        <div class="action-buttons" style="margin-bottom: 20px;">
            <button class="export-button" @click="exportToPDF">导出为PDF</button>
            <button class="clear-cache-button" @click="clearCache" :disabled="!hasCachedData">清除缓存</button>
        </div>
        
        <div class="notification" :class="{'show': showNotification}">
            {{ notificationMessage }}
        </div>
    </div>

    <script>
        new Vue({
            el: '#app',
            data: {
                uploadBoxes: [],
                showNotification: false,
                notificationMessage: '',
                // 拖拽相关变量
                draggedIndex: null,
                // 触摸拖拽相关变量
                touchItem: null,
                touchOffset: { x: 0, y: 0 },
                touchStartTime: 0,
                isTouchDragging: false,
                longPressTimer: null
            },
            computed: {
                hasCachedData() {
                    // 检查是否有已上传的图片数据
                    return this.uploadBoxes.some(box => box.image !== null);
                },
                isMobile() {
                    // 检测是否为移动设备
                    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                           (window.innerWidth <= 768 && 'ontouchstart' in window);
                }
            },
            created() {
                // 从localStorage读取数据
                const savedData = localStorage.getItem('imageUploaderData');
                if (savedData) {
                    try {
                        const parsedData = JSON.parse(savedData);
                        this.uploadBoxes = parsedData;
                        console.log('从localStorage恢复数据成功');
                    } catch (error) {
                        console.error('解析localStorage数据失败:', error);
                        this.initializeUploadBoxes();
                    }
                } else {
                    this.initializeUploadBoxes();
                }
            },
            watch: {
                // 深度监听uploadBoxes数组变化，实时保存到localStorage
                uploadBoxes: {
                    handler(newVal) {
                        localStorage.setItem('imageUploaderData', JSON.stringify(newVal));
                        console.log('数据已保存到localStorage');
                    },
                    deep: true
                }
            },
            methods: {
                // 清除缓存数据
                clearCache() {
                    if (confirm('确定要清除所有已保存的数据吗？此操作不可恢复。')) {
                        localStorage.removeItem('imageUploaderData');
                        this.initializeUploadBoxes();
                        this.showNotificationMsg('缓存已清除');
                        console.log('缓存已清除');
                    }
                },
                // 初始化20个上传框
                initializeUploadBoxes() {
                    this.uploadBoxes = [
                        { image: null, description: '', rotation: 0, isDragging: false, isDragOver: false },
                        { image: null, description: '', rotation: 0, isDragging: false, isDragOver: false },
                        { image: null, description: '', rotation: 0, isDragging: false, isDragOver: false },
                        { image: null, description: '', rotation: 0, isDragging: false, isDragOver: false },
                        { image: null, description: '', rotation: 0, isDragging: false, isDragOver: false },
                        { image: null, description: '', rotation: 0, isDragging: false, isDragOver: false },
                        { image: null, description: '', rotation: 0, isDragging: false, isDragOver: false },
                        { image: null, description: '', rotation: 0, isDragging: false, isDragOver: false },
                        { image: null, description: '', rotation: 0, isDragging: false, isDragOver: false },
                        { image: null, description: '', rotation: 0, isDragging: false, isDragOver: false },
                        { image: null, description: '', rotation: 0, isDragging: false, isDragOver: false },
                        { image: null, description: '', rotation: 0, isDragging: false, isDragOver: false },
                        { image: null, description: '', rotation: 0, isDragging: false, isDragOver: false },
                        { image: null, description: '', rotation: 0, isDragging: false, isDragOver: false },
                        { image: null, description: '', rotation: 0, isDragging: false, isDragOver: false },
                        { image: null, description: '', rotation: 0, isDragging: false, isDragOver: false },
                        { image: null, description: '', rotation: 0, isDragging: false, isDragOver: false },
                        { image: null, description: '', rotation: 0, isDragging: false, isDragOver: false },
                        { image: null, description: '', rotation: 0, isDragging: false, isDragOver: false },
                        { image: null, description: '', rotation: 0, isDragging: false, isDragOver: false }
                    ];
                    console.log('初始化上传框完成');
                },
                async handleFileChange(event, index) {
                    const file = event.target.files[0];
                    if (file && file.type.startsWith('image/')) {
                        try {
                            // 读取EXIF方向信息
                            const orientation = await this.getOrientation(file);
                            
                            // 读取图片数据
                            const reader = new FileReader();
                            reader.onload = async (e) => {
                                // 根据EXIF方向修正图片
                                const fixedImage = await this.fixImageOrientation(e.target.result, orientation);
                                
                                // 设置修正后的图片到上传框
                                this.$set(this.uploadBoxes, index, {
                                    ...this.uploadBoxes[index],
                                    image: fixedImage,
                                    rotation: 0 // 新上传图片重置旋转角度
                                });
                            };
                            reader.readAsDataURL(file);
                        } catch (error) {
                            console.error('处理图片方向时出错:', error);
                            // 出错时仍显示原始图片
                            const reader = new FileReader();
                            reader.onload = (e) => {
                                this.$set(this.uploadBoxes, index, {
                                    ...this.uploadBoxes[index],
                                    image: e.target.result,
                                    rotation: 0
                                });
                            };
                            reader.readAsDataURL(file);
                        }
                    } else {
                        this.showNotificationMsg('请选择有效的图片文件');
                    }
                },
                
                getImageStyle(rotation) {
                    // 根据旋转角度计算合适的缩放比例
                    const rotationAngle = rotation % 360;
                    let scale = 1;
                    
                    // 当旋转90或270度时，图片的宽高会互换，需要缩小以适应容器
                    if (rotationAngle === 90 || rotationAngle === 270) {
                        scale = 0.7; // 缩小到70%以完整显示
                    }
                    
                    return {
                        transform: `rotate(${rotation}deg) scale(${scale})`,
                        transformOrigin: 'center'
                    };
                },
                
                rotateImage(index) {
                    const currentRotation = this.uploadBoxes[index].rotation;
                    this.$set(this.uploadBoxes, index, {
                        ...this.uploadBoxes[index],
                        rotation: (currentRotation + 90) % 360 // 每次旋转90度
                    });
                },
                
                removeImage(index) {
                    this.$set(this.uploadBoxes, index, {
                        ...this.uploadBoxes[index],
                        image: null
                    });
                    // 清空文件输入
                    const fileInput = document.getElementById('file-input-' + index);
                    if (fileInput) {
                        fileInput.value = '';
                    }
                },
                
                addUploadBox() {
                    const newIndex = this.uploadBoxes.length;
                    this.uploadBoxes.push({ 
                        image: null, 
                        description: '', 
                        rotation: 0,
                        isDragging: false,
                        isDragOver: false
                    });
                    this.showNotificationMsg('已添加新的上传框');
                },
                
                showNotificationMsg(message) {
                    this.notificationMessage = message;
                    this.showNotification = true;
                    
                    setTimeout(() => {
                        this.showNotification = false;
                    }, 3000);
                },
                
                // 拖拽相关方法
                handleDragStart(index, event) {
                    // 设置拖拽数据
                    event.dataTransfer.effectAllowed = 'move';
                    event.dataTransfer.setData('text/plain', index);
                    
                    // 设置拖拽状态
                    this.$set(this.uploadBoxes[index], 'isDragging', true);
                    
                    // 存储被拖拽元素的索引
                    this.draggedIndex = index;
                },
                
                handleDragEnd(index, event) {
                    // 清除拖拽状态
                    this.$set(this.uploadBoxes[index], 'isDragging', false);
                    
                    // 清除所有拖拽悬停状态
                    this.uploadBoxes.forEach((box, i) => {
                        if (box.isDragOver) {
                            this.$set(this.uploadBoxes[i], 'isDragOver', false);
                        }
                    });
                },
                
                handleDragOver(index, event) {
                    // 阻止默认行为，允许放置
                    if (event.preventDefault) {
                        event.preventDefault();
                    }
                    
                    event.dataTransfer.dropEffect = 'move';
                    return false;
                },
                
                handleDragEnter(index, event) {
                    // 如果不是自己，则设置悬停状态
                    if (this.draggedIndex !== index) {
                        this.$set(this.uploadBoxes[index], 'isDragOver', true);
                    }
                },
                
                handleDragLeave(index, event) {
                    // 检查是否真的离开了元素
                    const rect = event.currentTarget.getBoundingClientRect();
                    const x = event.clientX;
                    const y = event.clientY;
                    
                    if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {
                        this.$set(this.uploadBoxes[index], 'isDragOver', false);
                    }
                },
                
                handleDrop(index, event) {
                    // 阻止默认行为
                    if (event.stopPropagation) {
                        event.stopPropagation();
                    }
                    event.preventDefault();
                    
                    // 如果拖拽到自己上面，不做任何操作
                    if (this.draggedIndex === index) {
                        return;
                    }
                    
                    // 获取被拖拽的元素
                    const draggedItem = this.uploadBoxes[this.draggedIndex];
                    
                    // 从原位置移除
                    this.uploadBoxes.splice(this.draggedIndex, 1);
                    
                    // 计算新的插入位置（如果拖拽位置在原位置之后，需要调整索引）
                    const newIndex = this.draggedIndex < index ? index - 1 : index;
                    
                    // 在新位置插入
                    this.uploadBoxes.splice(newIndex, 0, draggedItem);
                    
                    // 清除拖拽状态
                    this.$set(this.uploadBoxes[newIndex], 'isDragging', false);
                    
                    // 显示提示
                    this.showNotificationMsg('图片顺序已调整');
                    
                    return false;
                },
                
                // 触摸事件处理方法（移动端支持）
                handleTouchStart(index, event) {
                    // 记录触摸开始时间，用于区分长按和短按
                    this.touchStartTime = Date.now();
                    
                    // 获取第一个触摸点
                    const touch = event.touches[0];
                    if (!touch) return;
                    
                    // 获取触摸元素的位置
                    const rect = event.currentTarget.getBoundingClientRect();
                    
                    // 计算触摸点相对于元素的位置
                    this.touchOffset.x = touch.clientX - rect.left;
                    this.touchOffset.y = touch.clientY - rect.top;
                    
                    // 记录被触摸的元素
                    this.touchItem = index;
                    
                    // 设置长按定时器
                    this.longPressTimer = setTimeout(() => {
                        // 长按后启用拖拽模式
                        this.isTouchDragging = true;
                        this.$set(this.uploadBoxes[index], 'isDragging', true);
                        
                        // 添加震动反馈（如果设备支持）
                        if (navigator.vibrate) {
                            navigator.vibrate(50);
                        }
                    }, 800); // 800ms后启用拖拽
                    
                    // 不阻止默认行为，允许正常的触摸交互
                },
                
                handleTouchMove(index, event) {
                    // 如果没有触摸项或不在拖拽模式，不处理
                    if (this.touchItem === null || !this.isTouchDragging) return;
                    
                    // 防止默认的触摸行为（如滚动）
                    event.preventDefault();
                    
                    // 获取第一个触摸点
                    const touch = event.touches[0];
                    if (!touch) return;
                    
                    // 获取当前触摸的元素
                    const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (!elementBelow) return;
                    
                    // 查找最近的upload-box父元素
                    const dropTarget = elementBelow.closest('.upload-box');
                    if (!dropTarget) return;
                    
                    // 获取所有upload-box元素
                    const allBoxes = Array.from(document.querySelectorAll('.upload-box'));
                    const dropIndex = allBoxes.indexOf(dropTarget);
                    
                    // 如果找到了有效的放置目标，并且不是当前拖拽的元素
                    if (dropIndex !== -1 && dropIndex !== this.touchItem) {
                        // 清除所有拖拽悬停状态
                        this.uploadBoxes.forEach((box, i) => {
                            if (box.isDragOver && i !== dropIndex) {
                                this.$set(this.uploadBoxes[i], 'isDragOver', false);
                            }
                        });
                        
                        // 设置新的拖拽悬停状态
                        this.$set(this.uploadBoxes[dropIndex], 'isDragOver', true);
                    }
                },
                
                handleTouchEnd(index, event) {
                    // 清除长按定时器
                    if (this.longPressTimer) {
                        clearTimeout(this.longPressTimer);
                        this.longPressTimer = null;
                    }
                    
                    // 如果没有触摸项，不处理
                    if (this.touchItem === null) return;
                    
                    // 如果不是拖拽模式，不处理
                    if (!this.isTouchDragging) {
                        this.resetTouchState();
                        return;
                    }
                    
                    // 防止默认的触摸行为
                    event.preventDefault();
                    
                    // 获取最后一个触摸点
                    const touch = event.changedTouches[0];
                    if (!touch) {
                        this.resetTouchState();
                        return;
                    }
                    
                    // 获取触摸结束时的元素
                    const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (!elementBelow) {
                        this.resetTouchState();
                        return;
                    }
                    
                    // 查找最近的upload-box父元素
                    const dropTarget = elementBelow.closest('.upload-box');
                    if (!dropTarget) {
                        this.resetTouchState();
                        return;
                    }
                    
                    // 获取所有upload-box元素
                    const allBoxes = Array.from(document.querySelectorAll('.upload-box'));
                    const dropIndex = allBoxes.indexOf(dropTarget);
                    
                    // 如果找到了有效的放置目标，并且不是当前拖拽的元素
                    if (dropIndex !== -1 && dropIndex !== this.touchItem) {
                        // 执行移动操作
                        const draggedItem = this.uploadBoxes[this.touchItem];
                        
                        // 从原位置移除
                        this.uploadBoxes.splice(this.touchItem, 1);
                        
                        // 计算新的插入位置
                        const newIndex = this.touchItem < dropIndex ? dropIndex - 1 : dropIndex;
                        
                        // 在新位置插入
                        this.uploadBoxes.splice(newIndex, 0, draggedItem);
                        
                        // 显示提示
                        this.showNotificationMsg('图片顺序已调整');
                        
                        // 添加震动反馈（如果设备支持）
                        if (navigator.vibrate) {
                            navigator.vibrate([50, 30, 50]);
                        }
                    }
                    
                    // 重置触摸状态
                    this.resetTouchState();
                },
                
                handleTouchCancel(index, event) {
                    // 清除长按定时器
                    if (this.longPressTimer) {
                        clearTimeout(this.longPressTimer);
                        this.longPressTimer = null;
                    }
                    
                    // 触摸取消时重置状态
                    this.resetTouchState();
                },
                
                // 重置触摸状态
                resetTouchState() {
                    // 清除长按定时器
                    if (this.longPressTimer) {
                        clearTimeout(this.longPressTimer);
                        this.longPressTimer = null;
                    }
                    
                    // 清除所有拖拽和悬停状态
                    this.uploadBoxes.forEach((box, i) => {
                        if (box.isDragging) {
                            this.$set(this.uploadBoxes[i], 'isDragging', false);
                        }
                        if (box.isDragOver) {
                            this.$set(this.uploadBoxes[i], 'isDragOver', false);
                        }
                    });
                    
                    // 重置触摸相关变量
                    this.touchItem = null;
                    this.touchOffset = { x: 0, y: 0 };
                    this.touchStartTime = 0;
                    this.isTouchDragging = false;
                },
                
                // 中文文本换行处理
                wrapText(pdf, text, maxWidth) {
                    const lines = [];
                    let currentLine = '';
                    let currentWidth = 0;
                    const fontSize = pdf.internal.getFontSize();
                    
                    for (let i = 0; i < text.length; i++) {
                        const char = text.charAt(i);
                        const charWidth = pdf.getTextWidth(char);
                        
                        if (currentWidth + charWidth > maxWidth) {
                            lines.push(currentLine);
                            currentLine = char;
                            currentWidth = charWidth;
                        } else {
                            currentLine += char;
                            currentWidth += charWidth;
                        }
                    }
                    
                    if (currentLine) {
                        lines.push(currentLine);
                    }
                    
                    return lines;
                },
                
                // 在Canvas上绘制中文文本并返回dataURL（简化实现，提高可靠性）
                drawChineseTextOnCanvas(text, maxWidth, fontSize = 14) {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // 直接设置合适的字体
                    ctx.font = `${fontSize}px Microsoft YaHei, SimHei, Arial`;
                    ctx.fillStyle = '#000000';
                    ctx.textBaseline = 'middle'; // 使用middle基线，更可靠
                    ctx.textAlign = 'center';
                    
                    // 计算文本换行
                    const lines = this.wrapTextInCanvas(ctx, text, maxWidth);
                    
                    // 设置Canvas尺寸
                    const lineHeight = fontSize * 2; // 增加行高，提高可读性
                    const canvasWidth = maxWidth;
                    const canvasHeight = lines.length * lineHeight + 10; // 增加额外空间，避免裁剪
                    
                    canvas.width = canvasWidth;
                    canvas.height = canvasHeight;
                    
                    // 重新设置字体（Canvas尺寸改变后需要重新设置）
                    ctx.font = `${fontSize}px Microsoft YaHei, SimHei, Arial`;
                    ctx.fillStyle = '#000000';
                    ctx.textBaseline = 'middle'; // 使用middle基线，更可靠
                    ctx.textAlign = 'center';
                    
                    // 绘制文本
                    lines.forEach((line, index) => {
                        const y = index * lineHeight + lineHeight / 2 + 5; // 居中对齐并添加偏移
                        ctx.fillText(line, canvasWidth / 2, y);
                    });
                    
                    return canvas.toDataURL('image/png');
                },
                
                async exportToPDF() {
                    // 检查是否有图片上传
                    const hasImages = this.uploadBoxes.some(box => box.image !== null);
                    
                    if (!hasImages) {
                        this.showNotificationMsg('请至少上传一张图片');
                        return;
                    }
                    
                    try {
                        this.showNotificationMsg('正在生成PDF，请稍候...');
                        console.log('开始生成PDF');
                        
                        // 创建PDF实例
                        const pdf = new jspdf.jsPDF({
                            orientation: 'portrait',
                            unit: 'mm',
                            format: 'a4'
                        });
                        
                        const A4_WIDTH = 210;
                        const A4_HEIGHT = 297;
                        const MARGIN = 8; // 减少页边距，增加可用宽度
                        const TOP_MARGIN = 40; // 进一步减少顶部空间，给图片更多高度
                        const SECTION_HEIGHT = (A4_HEIGHT - TOP_MARGIN - MARGIN) / 2; // 简化计算，去掉不必要的15mm预留
                        const dpr = window.devicePixelRatio || 4; // 提高DPI到4倍
                        
                        // 筛选出有图片的上传框
                        const imagesWithDescription = this.uploadBoxes.filter(box => box.image !== null);
                        console.log('筛选出的图片数量:', imagesWithDescription.length);
                        
                        // 每页两张图片，计算总页数
                        const totalPages = Math.ceil(imagesWithDescription.length / 2);
                        console.log('总页数:', totalPages);
                        
                        // 处理每一页
                        for (let page = 0; page < totalPages; page++) {
                            console.log('处理第', page + 1, '页');
                            
                            // 添加新页（第一页除外）
                            if (page > 0) {
                                pdf.addPage();
                                console.log('添加新页');
                            }
                            
                            // 直接在PDF中绘制左上角文字logo: Mettler Toledo Service
                            // 使用统一的基线对齐确保在同一行
                            const logoY = MARGIN;
                            
                            // 先绘制Mettler Toledo (深蓝色)
                            pdf.setFontSize(16);
                            pdf.setFont('helvetica', 'bold');
                            pdf.setTextColor(0, 51, 102); // 深蓝色 (#003366)
                            pdf.text('Mettler Toledo', MARGIN, logoY);
                            
                            // 紧接着绘制Service (浅绿色)，保持在同一行
                            pdf.setFontSize(16); // 使用相同的字体大小确保对齐
                            pdf.setFont('helvetica', 'normal');
                            pdf.setTextColor(76, 175, 80); // 浅绿色 (#4CAF50)
                            // 计算"Mettler Toledo"的宽度，确保Service紧接着显示
                            const mtWidth = pdf.getTextWidth('Mettler Toledo');
                            // 使用相同的y坐标，确保完美对齐
                            pdf.text('Service', MARGIN + mtWidth + 5, logoY);
                            
                            // 使用高分辨率Canvas绘制中文标题和日期
                            // 绘制标题
                            const titleCanvas = document.createElement('canvas');
                            const titleCtx = titleCanvas.getContext('2d');
                            const titleFontSize = 20;
                            const titleText = '确证附件';
                            
                            // 设置超高分辨率
                            const titleMaxWidth = 400;
                            
                            // 计算所需高度
                            const titleLineHeight = titleFontSize * 1.5;
                            const requiredHeight = titleLineHeight + 20; // 增加额外空间，避免裁剪
                            
                            // 设置Canvas尺寸
                            titleCanvas.width = titleMaxWidth * dpr;
                            titleCanvas.height = requiredHeight * dpr;
                            titleCanvas.style.width = titleMaxWidth + 'px';
                            titleCanvas.style.height = requiredHeight + 'px';
                            
                            // 缩放上下文
                            titleCtx.scale(dpr, dpr);
                            
                            // 设置字体和样式
                            titleCtx.font = `${titleFontSize}px SimHei, Microsoft YaHei, Arial`;
                            titleCtx.fillStyle = '#000000';
                            titleCtx.textBaseline = 'middle'; // 使用middle基线，更可靠
                            titleCtx.textAlign = 'center';
                            
                            // 绘制标题
                            titleCtx.fillText(titleText, titleMaxWidth / 2, requiredHeight / 2);
                            
                            // 转换为图片并添加到PDF
                            const titleDataURL = titleCanvas.toDataURL('image/png', 1.0);
                            const titleImg = new Image();
                            titleImg.src = titleDataURL;
                            await new Promise(resolve => titleImg.onload = resolve);
                            pdf.addImage(titleImg, 'PNG', (A4_WIDTH - 120) / 2, 10, 120, 25);
                            
                            // 直接在PDF中绘制页脚日期（只显示数字日期）和页码
                            // 设置字体大小和样式
                            pdf.setFontSize(12);
                            pdf.setFont('helvetica', 'normal');
                            pdf.setTextColor(0, 0, 0); // 黑色
                            // 获取当前日期，格式化为YYYY-MM-DD或YYYY年MM月DD日
                            const currentDate = new Date().toLocaleDateString('zh-CN');
                            // 在左侧显示日期
                            const dateX = MARGIN + 5; // 左侧对齐
                            const dateY = A4_HEIGHT - 20;
                            pdf.text(currentDate, dateX, dateY, { align: 'left' });
                            
                            // 在右侧添加英文页码
                            const pageNumber = page + 1; // 当前页码
                            const pageText = `Page ${pageNumber} of ${totalPages}`;
                            const pageTextX = A4_WIDTH - MARGIN - 5; // 靠右对齐
                            pdf.text(pageText, pageTextX, dateY, { align: 'right' });
                            
                            // 添加分隔线
                            pdf.setDrawColor(0, 0, 0);
                            pdf.setLineWidth(0.5);
                            pdf.line(MARGIN, 30, A4_WIDTH - MARGIN, 30);
                            
                            // 获取当前页的两张图片
                            const pageImages = imagesWithDescription.slice(page * 2, page * 2 + 2);
                            console.log('当前页图片数量:', pageImages.length);
                            
                            // 处理上下两部分
                            for (let sectionIndex = 0; sectionIndex < pageImages.length; sectionIndex++) {
                                const imageData = pageImages[sectionIndex];
                                if (imageData) {
                                    console.log('处理图片:', imagesWithDescription.indexOf(imageData) + 1);
                                    const yPosition = TOP_MARGIN + sectionIndex * SECTION_HEIGHT;
                                    
                                    // 获取旋转后的图片
                                    const rotatedImage = await this.rotateImageData(imageData.image, imageData.rotation);
                                    
                                    // 创建临时图片元素用于测量旋转后的图片
                                    const tempImg = new Image();
                                    tempImg.src = rotatedImage;
                                    await new Promise(resolve => tempImg.onload = resolve);
                                    console.log('旋转后图片加载完成');
                                    
                                    // 图片尺寸计算
                            const imgWidth = tempImg.width;
                            const imgHeight = tempImg.height;
                            
                            // 为图片和描述分别分配空间，避免重叠
                            const IMAGE_PADDING = 5; // 图片内边距
                            const MAX_DESCRIPTIO_HEIGHT = 20; // 描述文字最大高度，不再固定
                            
                            // 计算图片可用区域，优先保证图片有足够空间
                            const availableWidth = A4_WIDTH - MARGIN * 2;
                            const availableImageHeight = SECTION_HEIGHT - MAX_DESCRIPTIO_HEIGHT - IMAGE_PADDING * 2;
                            
                            // 计算缩放比例 - 允许图片放大，确保填充可用空间
                            const scaleX = availableWidth / imgWidth;
                            const scaleY = availableImageHeight / imgHeight;
                            const scale = Math.min(scaleX, scaleY); // 去掉scale最大为1的限制，允许图片放大以填充空间
                            
                            const finalWidth = imgWidth * scale;
                            const finalHeight = imgHeight * scale;
                            
                            // 计算图片在区域中的居中位置
                            const imgX = (A4_WIDTH - finalWidth) / 2;
                            const imgY = yPosition + IMAGE_PADDING + (availableImageHeight - finalHeight) / 2;
                                    
                                    // 添加旋转后的图片到PDF
                                    pdf.addImage(rotatedImage, 'PNG', imgX, imgY, finalWidth, finalHeight);
                                    console.log('旋转后图片添加到PDF');
                                    console.log('旋转角度:', imageData.rotation);
                                    
                                    // 使用高分辨率Canvas绘制中文描述
                                    if (imageData.description) {
                                        const canvas = document.createElement('canvas');
                                        const ctx = canvas.getContext('2d');
                                        
                                        // 设置字体和大小
                                        const fontSize = 14;
                                        const lineHeight = fontSize * 1.5;
                                        
                                        // 计算文本换行
                                        ctx.font = `${fontSize}px SimHei, Microsoft YaHei, Arial`;
                                        const text = imageData.description;
                                        const lines = [];
                                        let currentLine = '';
                                        const maxWidth = 800; // 更大的宽度，提高分辨率
                                        
                                        for (let i = 0; i < text.length; i++) {
                                            const char = text.charAt(i);
                                            const testLine = currentLine + char;
                                            const testWidth = ctx.measureText(testLine).width;
                                            
                                            if (testWidth > maxWidth && i > 0) {
                                                lines.push(currentLine);
                                                currentLine = char;
                                            } else {
                                                currentLine = testLine;
                                            }
                                        }
                                        if (currentLine) {
                                            lines.push(currentLine);
                                        }
                                        
                                        // 设置超高分辨率Canvas尺寸，提高文字清晰度
                                        const dpr = window.devicePixelRatio || 4; // 提高DPI到4倍
                                        const canvasHeight = lines.length * lineHeight * dpr + 10 * dpr; // 增加额外空间，避免裁剪
                                        
                                        canvas.width = maxWidth * dpr;
                                        canvas.height = canvasHeight;
                                        canvas.style.width = maxWidth + 'px';
                                        canvas.style.height = (lines.length * lineHeight + 10) + 'px';
                                        
                                        // 缩放上下文
                                        ctx.scale(dpr, dpr);
                                        
                                        // 重新设置字体和样式
                                        ctx.font = `${fontSize}px SimHei, Microsoft YaHei, Arial`;
                                        ctx.fillStyle = '#000000';
                                        ctx.textBaseline = 'middle'; // 使用middle基线，更可靠
                                        ctx.textAlign = 'center';
                                        
                                        // 绘制文本
                                        lines.forEach((line, index) => {
                                            const y = index * lineHeight + lineHeight / 2 + 5; // 居中对齐并添加偏移
                                            ctx.fillText(line, maxWidth / 2, y);
                                        });
                                        
                                        // 转换为图片并添加到PDF
                                        const descDataURL = canvas.toDataURL('image/png', 1.0); // 高质量输出
                                        const descImg = new Image();
                                        descImg.src = descDataURL;
                                        await new Promise(resolve => descImg.onload = resolve);
                                        
                                        // 计算在PDF中的尺寸
                                        const descWidth = A4_WIDTH - MARGIN * 2;
                                        const descHeight = (descImg.height / dpr * descWidth) / (descImg.width / dpr);
                                        
                                        // 添加到PDF - 固定显示在图片下方
                                    pdf.addImage(descImg, 'PNG', MARGIN, yPosition + SECTION_HEIGHT - MAX_DESCRIPTIO_HEIGHT, descWidth, descHeight);
                                    console.log('描述添加到PDF');
                                    console.log('图片尺寸:', finalWidth, 'x', finalHeight);
                                    console.log('描述位置:', yPosition + SECTION_HEIGHT - MAX_DESCRIPTIO_HEIGHT);
                                    }
                                }
                            }
                        }
                        
                        // 保存PDF
                        console.log('准备保存PDF');
                        pdf.save('image-document.pdf');
                        console.log('PDF保存完成');
                        
                        this.showNotificationMsg('PDF已成功生成并下载');
                    } catch (error) {
                        console.error('生成PDF时出错:', error);
                        console.error('错误堆栈:', error.stack);
                        this.showNotificationMsg('生成PDF时出错，请查看控制台日志');
                    }
                },
                
                // Canvas文本换行处理
                wrapTextInCanvas(ctx, text, maxWidth) {
                    const lines = [];
                    let currentLine = '';
                    
                    for (let i = 0; i < text.length; i++) {
                        const char = text.charAt(i);
                        const testLine = currentLine + char;
                        const metrics = ctx.measureText(testLine);
                        const testWidth = metrics.width;
                        
                        if (testWidth > maxWidth && i > 0) {
                            lines.push(currentLine);
                            currentLine = char;
                        } else {
                            currentLine = testLine;
                        }
                    }
                    
                    if (currentLine) {
                        lines.push(currentLine);
                    }
                    
                    return lines;
                },
                
                // 读取图片的EXIF方向信息
                getOrientation(file) {
                    return new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            const view = new DataView(e.target.result);
                            if (view.getUint16(0, false) != 0xFFD8) {
                                resolve(1); // 不是JPEG，返回默认方向
                                return;
                            }
                            const length = view.byteLength;
                            let offset = 2;
                            while (offset < length) {
                                if (view.getUint16(offset + 2, false) <= 8) {
                                    resolve(1); // 无效的EXIF数据，返回默认方向
                                    return;
                                }
                                const marker = view.getUint16(offset, false);
                                offset += 2;
                                if (marker == 0xFFE1) {
                                    if (view.getUint32(offset += 2, false) != 0x45786966) {
                                        resolve(1); // 不是EXIF数据，返回默认方向
                                        return;
                                    }
                                    const little = view.getUint16(offset += 6, false) == 0x4949;
                                    offset += view.getUint32(offset + 4, little);
                                    const tags = view.getUint16(offset, little);
                                    offset += 2;
                                    for (let i = 0; i < tags; i++) {
                                        if (view.getUint16(offset + (i * 12), little) == 0x0112) {
                                            resolve(view.getUint16(offset + (i * 12) + 8, little));
                                            return;
                                        }
                                    }
                                } else if ((marker & 0xFF00) != 0xFF00) {
                                    break;
                                } else {
                                    offset += view.getUint16(offset, false);
                                }
                            }
                            resolve(1); // 默认方向
                        };
                        reader.readAsArrayBuffer(file.slice(0, 64 * 1024)); // 只读取文件头，提高效率
                    });
                },
                
                // 根据EXIF方向修正图片
                async fixImageOrientation(imageUrl, orientation) {
                    if (orientation === 1) {
                        return imageUrl; // 无需修正，直接返回原图
                    }
                    
                    const tempImg = new Image();
                    tempImg.src = imageUrl;
                    await new Promise(resolve => tempImg.onload = resolve);
                    
                    // 创建Canvas用于修正方向
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // 保存原始图片尺寸
                    const originalWidth = tempImg.width;
                    const originalHeight = tempImg.height;
                    
                    // 根据方向调整Canvas尺寸
                    let canvasWidth = originalWidth;
                    let canvasHeight = originalHeight;
                    
                    // 方向1: 正常
                    // 方向2: 水平翻转
                    // 方向3: 旋转180度
                    // 方向4: 垂直翻转
                    // 方向5: 顺时针旋转90度，水平翻转
                    // 方向6: 顺时针旋转90度
                    // 方向7: 顺时针旋转90度，垂直翻转
                    // 方向8: 逆时针旋转90度
                    if ([5, 6, 7, 8].includes(orientation)) {
                        [canvasWidth, canvasHeight] = [originalHeight, originalWidth]; // 旋转90度，交换宽高
                    }
                    
                    canvas.width = canvasWidth;
                    canvas.height = canvasHeight;
                    
                    // 设置高质量渲染
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    
                    // 根据方向进行变换
                    switch (orientation) {
                        case 2: // 水平翻转
                            ctx.translate(canvasWidth, 0);
                            ctx.scale(-1, 1);
                            ctx.drawImage(tempImg, 0, 0);
                            break;
                        case 3: // 旋转180度
                            ctx.translate(canvasWidth, canvasHeight);
                            ctx.rotate(Math.PI);
                            ctx.drawImage(tempImg, 0, 0);
                            break;
                        case 4: // 垂直翻转
                            ctx.translate(0, canvasHeight);
                            ctx.scale(1, -1);
                            ctx.drawImage(tempImg, 0, 0);
                            break;
                        case 5: // 顺时针旋转90度，水平翻转
                            ctx.rotate(0.5 * Math.PI);
                            ctx.scale(1, -1);
                            ctx.drawImage(tempImg, 0, -originalHeight);
                            break;
                        case 6: // 顺时针旋转90度
                            ctx.rotate(0.5 * Math.PI);
                            ctx.drawImage(tempImg, 0, -originalHeight);
                            break;
                        case 7: // 顺时针旋转90度，垂直翻转
                            ctx.translate(canvasWidth, canvasHeight);
                            ctx.rotate(0.5 * Math.PI);
                            ctx.scale(-1, 1);
                            ctx.drawImage(tempImg, -originalWidth, -originalHeight);
                            break;
                        case 8: // 逆时针旋转90度
                            ctx.translate(0, originalWidth);
                            ctx.rotate(-0.5 * Math.PI);
                            ctx.drawImage(tempImg, 0, 0);
                            break;
                        default:
                            ctx.drawImage(tempImg, 0, 0);
                            break;
                    }
                    
                    return canvas.toDataURL('image/png', 1.0);
                },
                
                // 旋转图片并返回旋转后的dataURL（包含EXIF方向修正）
                async rotateImageData(imageUrl, rotation) {
                    if (rotation === 0) {
                        return imageUrl; // 无需旋转，直接返回原图
                    }
                    
                    const tempImg = new Image();
                    tempImg.src = imageUrl;
                    await new Promise(resolve => tempImg.onload = resolve);
                    
                    // 创建Canvas用于旋转图片
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // 根据旋转角度调整Canvas尺寸
                    const totalRotation = rotation % 360;
                    const angle = (totalRotation * Math.PI) / 180;
                    const cos = Math.abs(Math.cos(angle));
                    const sin = Math.abs(Math.sin(angle));
                    const newWidth = Math.ceil(tempImg.width * cos + tempImg.height * sin);
                    const newHeight = Math.ceil(tempImg.width * sin + tempImg.height * cos);
                    
                    canvas.width = newWidth;
                    canvas.height = newHeight;
                    
                    // 设置高质量渲染
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    
                    // 设置旋转中心和旋转角度
                    ctx.translate(newWidth / 2, newHeight / 2);
                    ctx.rotate(angle);
                    
                    // 绘制旋转后的图片
                    ctx.drawImage(tempImg, -tempImg.width / 2, -tempImg.height / 2);
                    
                    // 转换为dataURL，使用高质量设置
                    return canvas.toDataURL('image/png', 1.0);
                }
            }
        });
    </script>
</body>
</html>